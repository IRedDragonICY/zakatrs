//! Dart test file generator for polyglot compliance testing.
//!
//! This module generates native Dart/Flutter test files directly from test cases,
//! eliminating the need for runtime JSON parsing in the Dart test runner.

use crate::schema::{AssetType, TestCase};
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

/// Header comment for generated files.
const GENERATED_HEADER: &str = r#"// AUTOMATICALLY GENERATED - DO NOT EDIT
// This file was generated by zakat-test-gen.
// Any manual changes will be overwritten when the generator runs.
//
// To regenerate: cargo run -p zakat-test-gen
"#;

/// Generates a Dart Flutter test file from the given test cases.
///
/// # Arguments
/// * `cases` - Slice of test cases to generate tests for
/// * `out_path` - Path where the generated Dart file will be written
///
/// # Errors
/// Returns an error if the file cannot be created or written to.
pub fn generate_dart_tests(cases: &[TestCase], out_path: &Path) -> io::Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut file = File::create(out_path)?;

    // Write header
    writeln!(file, "{}", GENERATED_HEADER)?;
    writeln!(file)?;

    // Write library directive and imports
    writeln!(file, "library;")?;
    writeln!(file)?;
    writeln!(file, "import 'package:flutter_test/flutter_test.dart';")?;
    writeln!(file, "import 'package:zakat/zakat.dart';")?;
    writeln!(file, "import 'package:decimal/decimal.dart';")?;
    writeln!(file)?;

    // Helper function for decimal comparison
    writeln!(file, "/// Compares two decimal strings with tolerance.")?;
    writeln!(file, "void expectDecimalEqual(String actual, String expected, String message) {{")?;
    writeln!(file, "  final actualDec = double.tryParse(actual) ?? 0.0;")?;
    writeln!(file, "  final expectedDec = double.tryParse(expected) ?? 0.0;")?;
    writeln!(file, "  final diff = (actualDec - expectedDec).abs();")?;
    writeln!(file)?;
    writeln!(file, "  expect(")?;
    writeln!(file, "    diff,")?;
    writeln!(file, "    lessThan(0.0000001),")?;
    writeln!(file, "    reason: '$message\\nExpected: $expected\\nActual: $actual',")?;
    writeln!(file, "  );")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Begin main function
    writeln!(file, "void main() {{")?;
    writeln!(file, "  setUpAll(() async {{")?;
    writeln!(file, "    // Initialize the Rust library")?;
    writeln!(file, "    await RustLib.init();")?;
    writeln!(file, "  }});")?;
    writeln!(file)?;

    // Group by asset type
    let business_cases: Vec<_> = cases.iter().filter(|c| c.asset_type == AssetType::Business).collect();
    let gold_cases: Vec<_> = cases.iter().filter(|c| c.asset_type == AssetType::Gold).collect();
    let silver_cases: Vec<_> = cases.iter().filter(|c| c.asset_type == AssetType::Silver).collect();

    // Generate business tests group
    if !business_cases.is_empty() {
        writeln!(file, "  group('Generated Business Compliance Tests', () {{")?;
        for case in &business_cases {
            generate_dart_test(&mut file, case, "    ")?;
        }
        writeln!(file, "  }});")?;
        writeln!(file)?;
    }

    // Generate gold tests group
    if !gold_cases.is_empty() {
        writeln!(file, "  group('Generated Gold Compliance Tests', () {{")?;
        for case in &gold_cases {
            generate_dart_test(&mut file, case, "    ")?;
        }
        writeln!(file, "  }});")?;
        writeln!(file)?;
    }

    // Generate silver tests group
    if !silver_cases.is_empty() {
        writeln!(file, "  group('Generated Silver Compliance Tests', () {{")?;
        for case in &silver_cases {
            generate_dart_test(&mut file, case, "    ")?;
        }
        writeln!(file, "  }});")?;
    }

    // Close main function
    writeln!(file, "}}")?;

    file.flush()?;
    Ok(())
}

/// Generates a single Dart test for a test case.
fn generate_dart_test(file: &mut File, case: &TestCase, indent: &str) -> io::Result<()> {
    let description = escape_dart_string(&case.description);

    // Skip error cases
    if case.expected.error_code.is_some() {
        writeln!(file, "{}test('{}', () {{", indent, description)?;
        writeln!(file, "{}  // TODO: Error case - expected error code: {}", 
                 indent, case.expected.error_code.as_deref().unwrap_or("unknown"))?;
        writeln!(file, "{}  // Skip error cases in generated tests", indent)?;
        writeln!(file, "{}}}, skip: 'Error case not yet implemented');", indent)?;
        writeln!(file)?;
        return Ok(());
    }

    // Skip non-Hanafi madhab for gold cases
    if case.asset_type == AssetType::Gold && case.config.madhab != "hanafi" {
        writeln!(file, "{}test('{}', () {{", indent, description)?;
        writeln!(file, "{}  // Non-Hanafi madhab not yet supported", indent)?;
        writeln!(file, "{}}}, skip: 'Madhab {} not yet supported');", indent, case.config.madhab)?;
        writeln!(file)?;
        return Ok(());
    }

    writeln!(file, "{}test('{}', () {{", indent, description)?;

    // Generate config
    writeln!(file, "{}  // Configuration", indent)?;
    writeln!(file, "{}  final config = DartZakatConfig(", indent)?;
    writeln!(file, "{}    goldPrice: Decimal.parse('{}').toFrb(),", 
             indent, escape_dart_string(&case.config.gold_price_per_gram))?;
    writeln!(file, "{}    silverPrice: Decimal.parse('{}').toFrb(),", 
             indent, escape_dart_string(&case.config.silver_price_per_gram))?;
    writeln!(file, "{}    madhab: '{}',", indent, escape_dart_string(&case.config.madhab))?;
    writeln!(file, "{}  );", indent)?;
    writeln!(file)?;

    // Generate asset based on type
    match case.asset_type {
        AssetType::Business => generate_dart_business_asset(file, case, indent)?,
        AssetType::Gold => generate_dart_gold_asset(file, case, indent)?,
        AssetType::Silver => generate_dart_silver_asset(file, case, indent)?,
        _ => {
            writeln!(file, "{}  // TODO: Asset type {:?} not yet supported", indent, case.asset_type)?;
            writeln!(file, "{}}}, skip: 'Asset type not supported');", indent)?;
            writeln!(file)?;
            return Ok(());
        }
    }

    // Generate assertions
    generate_dart_assertions(file, case, indent)?;

    writeln!(file, "{}}});", indent)?;
    writeln!(file)?;

    Ok(())
}

/// Generates Dart code for a DartBusiness asset.
fn generate_dart_business_asset(file: &mut File, case: &TestCase, indent: &str) -> io::Result<()> {
    let cash = get_field_str(&case.input.fields, "cash_on_hand", "0");
    let inventory = get_field_str(&case.input.fields, "inventory_value", "0");
    let receivables = get_field_str(&case.input.fields, "receivables", "0");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "{}  // Create business asset using fluent API", indent)?;
    writeln!(file, "{}  final asset = DartBusiness()", indent)?;
    writeln!(file, "{}    ..cash(value: Decimal.parse('{}').toFrb())", indent, escape_dart_string(&cash))?;
    writeln!(file, "{}    ..inventory(value: Decimal.parse('{}').toFrb())", indent, escape_dart_string(&inventory))?;
    writeln!(file, "{}    ..receivables(value: Decimal.parse('{}').toFrb())", indent, escape_dart_string(&receivables))?;
    writeln!(file, "{}    ..debt(value: Decimal.parse('{}').toFrb())", indent, escape_dart_string(liabilities))?;
    writeln!(file, "{}    ..hawl(value: {});", indent, dart_bool(hawl))?;
    writeln!(file)?;
    writeln!(file, "{}  // Calculate", indent)?;
    writeln!(file, "{}  final result = asset.calculate(config: config);", indent)?;

    Ok(())
}

/// Generates Dart code for a DartPreciousMetals gold asset.
fn generate_dart_gold_asset(file: &mut File, case: &TestCase, indent: &str) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "24");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    // Parse purity as integer
    let purity_int: u32 = purity.parse().unwrap_or(24);

    writeln!(file, "{}  // Create gold asset using fluent API", indent)?;
    writeln!(file, "{}  final asset = DartPreciousMetals.gold(", indent)?;
    writeln!(file, "{}    weightGrams: Decimal.parse('{}').toFrb(),", indent, escape_dart_string(&weight))?;
    writeln!(file, "{}  )", indent)?;
    writeln!(file, "{}    ..purity(value: {})", indent, purity_int)?;
    writeln!(file, "{}    ..debt(amount: Decimal.parse('{}').toFrb())", indent, escape_dart_string(liabilities))?;
    writeln!(file, "{}    ..hawl(satisfied: {});", indent, dart_bool(hawl))?;
    writeln!(file)?;
    writeln!(file, "{}  // Calculate", indent)?;
    writeln!(file, "{}  final result = asset.calculate(config: config);", indent)?;

    Ok(())
}

/// Generates Dart code for a DartPreciousMetals silver asset.
fn generate_dart_silver_asset(file: &mut File, case: &TestCase, indent: &str) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "1000");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    // Parse purity as integer
    let purity_int: u32 = purity.parse().unwrap_or(1000);

    writeln!(file, "{}  // Create silver asset using fluent API", indent)?;
    writeln!(file, "{}  final asset = DartPreciousMetals.silver(", indent)?;
    writeln!(file, "{}    weightGrams: Decimal.parse('{}').toFrb(),", indent, escape_dart_string(&weight))?;
    writeln!(file, "{}  )", indent)?;
    writeln!(file, "{}    ..purity(value: {})", indent, purity_int)?;
    writeln!(file, "{}    ..debt(amount: Decimal.parse('{}').toFrb())", indent, escape_dart_string(liabilities))?;
    writeln!(file, "{}    ..hawl(satisfied: {});", indent, dart_bool(hawl))?;
    writeln!(file)?;
    writeln!(file, "{}  // Calculate", indent)?;
    writeln!(file, "{}  final result = asset.calculate(config: config);", indent)?;

    Ok(())
}

/// Generates Dart assertion statements.
fn generate_dart_assertions(file: &mut File, case: &TestCase, indent: &str) -> io::Result<()> {
    let case_id = escape_dart_string(&case.id);
    let expected = &case.expected;
    let is_payable = dart_bool(expected.is_payable);

    writeln!(file)?;
    writeln!(file, "{}  // Assertions", indent)?;
    writeln!(file, "{}  expect(", indent)?;
    writeln!(file, "{}    result.isPayable,", indent)?;
    writeln!(file, "{}    {},", indent, is_payable)?;
    writeln!(file, "{}    reason: '[{}] is_payable mismatch',", indent, case_id)?;
    writeln!(file, "{}  );", indent)?;

    writeln!(file, "{}  expectDecimalEqual(", indent)?;
    writeln!(file, "{}    result.zakatDue.toDecimal().toString(),", indent)?;
    writeln!(file, "{}    '{}',", indent, escape_dart_string(&expected.zakat_due))?;
    writeln!(file, "{}    '[{}] zakat_due mismatch',", indent, case_id)?;
    writeln!(file, "{}  );", indent)?;

    writeln!(file, "{}  expectDecimalEqual(", indent)?;
    writeln!(file, "{}    result.netAssets.toDecimal().toString(),", indent)?;
    writeln!(file, "{}    '{}',", indent, escape_dart_string(&expected.net_assets))?;
    writeln!(file, "{}    '[{}] net_assets mismatch',", indent, case_id)?;
    writeln!(file, "{}  );", indent)?;

    Ok(())
}

// ============================================================================
// Helper functions
// ============================================================================

/// Gets a field value as a string from the input fields map.
fn get_field_str(
    fields: &std::collections::HashMap<String, serde_json::Value>,
    key: &str,
    default: &str,
) -> String {
    fields
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

/// Converts a Rust bool to Dart bool string.
fn dart_bool(b: bool) -> &'static str {
    if b { "true" } else { "false" }
}

/// Escapes a string for use in Dart string literals.
fn escape_dart_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
        .replace('$', "\\$")
}
