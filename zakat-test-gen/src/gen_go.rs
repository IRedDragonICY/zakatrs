//! Go test file generator for polyglot compliance testing.
//!
//! This module generates native Go test files directly from test cases,
//! eliminating the need for runtime JSON parsing in the Go test runner.

use crate::schema::{AssetType, TestCase};
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

/// Header comment for generated files.
const GENERATED_HEADER: &str = r#"// AUTOMATICALLY GENERATED - DO NOT EDIT
// This file was generated by zakat-test-gen.
// Any manual changes will be overwritten when the generator runs.
//
// To regenerate: cargo run -p zakat-test-gen
"#;

/// Generates a Go test file from the given test cases.
///
/// # Arguments
/// * `cases` - Slice of test cases to generate tests for
/// * `out_path` - Path where the generated Go file will be written
///
/// # Errors
/// Returns an error if the file cannot be created or written to.
pub fn generate_go_tests(cases: &[TestCase], out_path: &Path) -> io::Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut file = File::create(out_path)?;

    // Write header
    writeln!(file, "{}", GENERATED_HEADER)?;
    writeln!(file)?;

    // Write package declaration and imports
    writeln!(file, "package zakat")?;
    writeln!(file)?;
    writeln!(file, "import (")?;
    writeln!(file, "\t\"testing\"")?;
    writeln!(file)?;
    writeln!(file, "\t\"github.com/shopspring/decimal\"")?;
    writeln!(file, ")")?;
    writeln!(file)?;

    // Helper function for decimal comparison
    writeln!(file, "// assertDecimalEqual compares two decimal strings with tolerance.")?;
    writeln!(file, "func assertDecimalEqual(t *testing.T, actual, expected, msg string) {{")?;
    writeln!(file, "\tt.Helper()")?;
    writeln!(file, "\tactualDec, err := decimal.NewFromString(actual)")?;
    writeln!(file, "\tif err != nil {{")?;
    writeln!(file, "\t\tt.Errorf(\"%s: invalid actual decimal %q: %v\", msg, actual, err)")?;
    writeln!(file, "\t\treturn")?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\texpectedDec, err := decimal.NewFromString(expected)")?;
    writeln!(file, "\tif err != nil {{")?;
    writeln!(file, "\t\tt.Errorf(\"%s: invalid expected decimal %q: %v\", msg, expected, err)")?;
    writeln!(file, "\t\treturn")?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\ttolerance := decimal.NewFromFloat(0.0000001)")?;
    writeln!(file, "\tdiff := actualDec.Sub(expectedDec).Abs()")?;
    writeln!(file, "\tif diff.GreaterThan(tolerance) {{")?;
    writeln!(file, "\t\tt.Errorf(\"%s\\nExpected: %s\\nActual: %s\\nDiff: %s\", msg, expected, actual, diff)")?;
    writeln!(file, "\t}}")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Generate test functions for each case
    for case in cases {
        generate_go_test_function(&mut file, case)?;
    }

    file.flush()?;
    Ok(())
}

/// Generates a single Go test function for a test case.
fn generate_go_test_function(file: &mut File, case: &TestCase) -> io::Result<()> {
    let func_name = sanitize_go_identifier(&case.id);
    let description = escape_go_string(&case.description);

    // Skip error cases
    if case.expected.error_code.is_some() {
        writeln!(file, "// Test{} - Error case: {}", func_name, case.expected.error_code.as_deref().unwrap_or("unknown"))?;
        writeln!(file, "// TODO: Error case not yet implemented in generated tests")?;
        writeln!(file, "func Test{}(t *testing.T) {{", func_name)?;
        writeln!(file, "\tt.Skip(\"Error case not yet implemented\")")?;
        writeln!(file, "}}")?;
        writeln!(file)?;
        return Ok(());
    }

    // Skip non-Hanafi madhab for gold/silver cases
    if (case.asset_type == AssetType::Gold || case.asset_type == AssetType::Silver)
        && case.config.madhab != "hanafi"
    {
        writeln!(file, "// Test{} - Non-Hanafi madhab: {}", func_name, case.config.madhab)?;
        writeln!(file, "func Test{}(t *testing.T) {{", func_name)?;
        writeln!(file, "\tt.Skip(\"Madhab '{}' not yet supported\")", escape_go_string(&case.config.madhab))?;
        writeln!(file, "}}")?;
        writeln!(file)?;
        return Ok(());
    }

    writeln!(file, "// Test{} tests: {}", func_name, description)?;
    writeln!(file, "func Test{}(t *testing.T) {{", func_name)?;

    // Configuration comment
    writeln!(file, "\t// Configuration")?;
    writeln!(file, "\tconfig := NewConfig(\"{}\", \"{}\")",
             escape_go_string(&case.config.gold_price_per_gram),
             escape_go_string(&case.config.silver_price_per_gram))?;
    writeln!(file, "\t_ = config // TODO: Use config once bindings are generated")?;
    writeln!(file)?;

    // Generate asset based on type
    match case.asset_type {
        AssetType::Business => generate_go_business_asset(file, case)?,
        AssetType::Gold => generate_go_gold_asset(file, case)?,
        AssetType::Silver => generate_go_silver_asset(file, case)?,
        _ => {
            writeln!(file, "\t// TODO: Asset type {:?} not yet supported", case.asset_type)?;
            writeln!(file, "\tt.Skip(\"Asset type not supported\")")?;
            writeln!(file, "}}")?;
            writeln!(file)?;
            return Ok(());
        }
    }

    // Generate assertions (placeholder until bindings work)
    generate_go_assertions(file, case)?;

    writeln!(file, "}}")?;
    writeln!(file)?;

    Ok(())
}

/// Generates Go code for a BusinessInput asset.
fn generate_go_business_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let cash = get_field_str(&case.input.fields, "cash_on_hand", "0");
    let inventory = get_field_str(&case.input.fields, "inventory_value", "0");
    let receivables = get_field_str(&case.input.fields, "receivables", "0");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "\t// Create business asset")?;
    writeln!(file, "\tinput := BusinessInput{{")?;
    writeln!(file, "\t\tCashOnHand:     \"{}\",", escape_go_string(&cash))?;
    writeln!(file, "\t\tInventoryValue: \"{}\",", escape_go_string(&inventory))?;
    writeln!(file, "\t\tReceivables:    \"{}\",", escape_go_string(&receivables))?;
    writeln!(file, "\t\tLiabilities:    \"{}\",", escape_go_string(liabilities))?;
    writeln!(file, "\t\tHawlSatisfied:  {},", go_bool(hawl))?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\t_ = input // TODO: Call CalculateBusiness(input, config) once bindings available")?;

    Ok(())
}

/// Generates Go code for a Gold PreciousMetals asset.
fn generate_go_gold_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "24");
    let usage = get_field_str(&case.input.fields, "usage", "investment");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "\t// Create gold asset")?;
    writeln!(file, "\tinput := GoldInput{{")?;
    writeln!(file, "\t\tWeightGrams:   \"{}\",", escape_go_string(&weight))?;
    writeln!(file, "\t\tPurity:        \"{}\",", escape_go_string(&purity))?;
    writeln!(file, "\t\tUsage:         \"{}\",", normalize_usage(&usage))?;
    writeln!(file, "\t\tLiabilities:   \"{}\",", escape_go_string(liabilities))?;
    writeln!(file, "\t\tHawlSatisfied: {},", go_bool(hawl))?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\t_ = input // TODO: Call CalculateGold(input, config) once bindings available")?;

    Ok(())
}

/// Generates Go code for a Silver PreciousMetals asset.
fn generate_go_silver_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "1000");
    let usage = get_field_str(&case.input.fields, "usage", "investment");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "\t// Create silver asset")?;
    writeln!(file, "\tinput := SilverInput{{")?;
    writeln!(file, "\t\tWeightGrams:   \"{}\",", escape_go_string(&weight))?;
    writeln!(file, "\t\tPurity:        \"{}\",", escape_go_string(&purity))?;
    writeln!(file, "\t\tUsage:         \"{}\",", normalize_usage(&usage))?;
    writeln!(file, "\t\tLiabilities:   \"{}\",", escape_go_string(liabilities))?;
    writeln!(file, "\t\tHawlSatisfied: {},", go_bool(hawl))?;
    writeln!(file, "\t}}")?;
    writeln!(file, "\t_ = input // TODO: Call CalculateSilver(input, config) once bindings available")?;

    Ok(())
}

/// Generates Go assertion statements.
fn generate_go_assertions(file: &mut File, case: &TestCase) -> io::Result<()> {
    let case_id = escape_go_string(&case.id);
    let expected = &case.expected;
    let is_payable = go_bool(expected.is_payable);

    writeln!(file)?;
    writeln!(file, "\t// Expected results (for reference until bindings are complete)")?;
    writeln!(file, "\texpectedIsPayable := {}", is_payable)?;
    writeln!(file, "\texpectedZakatDue := \"{}\"", escape_go_string(&expected.zakat_due))?;
    writeln!(file, "\texpectedNetAssets := \"{}\"", escape_go_string(&expected.net_assets))?;
    writeln!(file)?;
    writeln!(file, "\t// TODO: Replace with actual assertions once bindings are available")?;
    writeln!(file, "\t// Example:")?;
    writeln!(file, "\t// result, err := CalculateBusiness(input, config)")?;
    writeln!(file, "\t// if err != nil {{")?;
    writeln!(file, "\t//     t.Fatalf(\"[{}] calculation failed: %v\", err)", case_id)?;
    writeln!(file, "\t// }}")?;
    writeln!(file, "\t// if result.IsPayable != expectedIsPayable {{")?;
    writeln!(file, "\t//     t.Errorf(\"[{}] is_payable mismatch: got %v, want %v\", result.IsPayable, expectedIsPayable)", case_id)?;
    writeln!(file, "\t// }}")?;
    writeln!(file, "\t// assertDecimalEqual(t, result.ZakatDue, expectedZakatDue, \"[{}] zakat_due mismatch\")", case_id)?;
    writeln!(file, "\t// assertDecimalEqual(t, result.NetAssets, expectedNetAssets, \"[{}] net_assets mismatch\")", case_id)?;
    writeln!(file)?;
    writeln!(file, "\t// Placeholder to use variables and prevent compile errors")?;
    writeln!(file, "\t_ = expectedIsPayable")?;
    writeln!(file, "\t_ = expectedZakatDue")?;
    writeln!(file, "\t_ = expectedNetAssets")?;
    writeln!(file, "\tt.Log(\"Test case {} defined - awaiting UniFFI bindings\")", case_id)?;

    Ok(())
}

// ============================================================================
// Helper functions
// ============================================================================

/// Gets a field value as a string from the input fields map.
fn get_field_str(
    fields: &std::collections::HashMap<String, serde_json::Value>,
    key: &str,
    default: &str,
) -> String {
    fields
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

/// Converts a Rust bool to Go bool string.
fn go_bool(b: bool) -> &'static str {
    if b { "true" } else { "false" }
}

/// Normalizes usage string to PascalCase.
fn normalize_usage(usage: &str) -> String {
    match usage.to_lowercase().as_str() {
        "investment" => "Investment".to_string(),
        "personal_use" | "personaluse" => "PersonalUse".to_string(),
        _ => {
            // Convert snake_case to PascalCase
            usage
                .split('_')
                .map(|word| {
                    let mut chars = word.chars();
                    match chars.next() {
                        Some(first) => first.to_uppercase().chain(chars).collect(),
                        None => String::new(),
                    }
                })
                .collect()
        }
    }
}

/// Sanitizes a string to be a valid Go identifier (PascalCase).
fn sanitize_go_identifier(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|part| !part.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().chain(chars).collect(),
                None => String::new(),
            }
        })
        .collect()
}

/// Escapes a string for use in Go string literals.
fn escape_go_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}
