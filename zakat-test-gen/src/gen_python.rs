//! Python test file generator for polyglot compliance testing.
//!
//! This module generates native Python unittest files directly from test cases,
//! eliminating the need for runtime JSON parsing in the Python test runner.

use crate::schema::{AssetType, TestCase};
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

/// Header comment for generated files.
const GENERATED_HEADER: &str = r#"# AUTOMATICALLY GENERATED - DO NOT EDIT
# This file was generated by zakat-test-gen.
# Any manual changes will be overwritten when the generator runs.
#
# To regenerate: cargo run -p zakat-test-gen
"#;

/// Generates a Python unittest file from the given test cases.
///
/// # Arguments
/// * `cases` - Slice of test cases to generate tests for
/// * `out_path` - Path where the generated Python file will be written
///
/// # Errors
/// Returns an error if the file cannot be created or written to.
pub fn generate_python_tests(cases: &[TestCase], out_path: &Path) -> io::Result<()> {
    // Ensure parent directory exists
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut file = File::create(out_path)?;

    // Write header
    writeln!(file, "{}", GENERATED_HEADER)?;
    writeln!(file)?;

    // Write imports
    writeln!(file, "import unittest")?;
    writeln!(file, "from decimal import Decimal, getcontext")?;
    writeln!(file)?;
    writeln!(file, "# Set high precision for decimal comparisons")?;
    writeln!(file, "getcontext().prec = 28")?;
    writeln!(file)?;
    writeln!(file, "try:")?;
    writeln!(file, "    import zakatrs")?;
    writeln!(file, "except ImportError as e:")?;
    writeln!(file, "    raise ImportError(")?;
    writeln!(file, "        \"zakatrs not installed. Run: maturin develop -m zakat/Cargo.toml\"")?;
    writeln!(file, "    ) from e")?;
    writeln!(file)?;
    writeln!(file)?;

    // Helper function for decimal comparison
    writeln!(file, "def assert_decimal_equal(test_case, actual, expected, msg=\"\"):")?;
    writeln!(file, "    \"\"\"Assert two decimal strings are equal within tolerance.\"\"\"")?;
    writeln!(file, "    actual_dec = Decimal(str(actual))")?;
    writeln!(file, "    expected_dec = Decimal(str(expected))")?;
    writeln!(file, "    diff = abs(actual_dec - expected_dec)")?;
    writeln!(file, "    tolerance = Decimal(\"0.0000001\")")?;
    writeln!(file, "    test_case.assertTrue(")?;
    writeln!(file, "        diff <= tolerance,")?;
    writeln!(file, "        f\"{{msg}}\\nExpected: {{expected_dec}}\\nActual: {{actual_dec}}\\nDiff: {{diff}}\"")?;
    writeln!(file, "    )")?;
    writeln!(file)?;
    writeln!(file)?;

    // Helper for normalizing usage enum
    writeln!(file, "def normalize_usage(usage):")?;
    writeln!(file, "    \"\"\"Convert snake_case usage to PascalCase for Rust enum.\"\"\"")?;
    writeln!(file, "    mapping = {{")?;
    writeln!(file, "        \"investment\": \"Investment\",")?;
    writeln!(file, "        \"personal_use\": \"PersonalUse\",")?;
    writeln!(file, "        \"personaluse\": \"PersonalUse\",")?;
    writeln!(file, "    }}")?;
    writeln!(file, "    return mapping.get(usage.lower(), usage.title().replace(\"_\", \"\"))")?;
    writeln!(file)?;
    writeln!(file)?;

    // Generate test class
    writeln!(file, "class TestGeneratedCompliance(unittest.TestCase):")?;
    writeln!(file, "    \"\"\"Generated compliance tests from zakat-test-gen.\"\"\"")?;
    writeln!(file)?;

    // Generate a test method for each case
    for case in cases {
        generate_python_test_method(&mut file, case)?;
    }

    // Main block
    writeln!(file)?;
    writeln!(file)?;
    writeln!(file, "if __name__ == \"__main__\":")?;
    writeln!(file, "    unittest.main(verbosity=2)")?;

    file.flush()?;
    Ok(())
}

/// Generates a single Python test method for a test case.
fn generate_python_test_method(file: &mut File, case: &TestCase) -> io::Result<()> {
    let method_name = sanitize_python_identifier(&case.id);
    let description = escape_python_string(&case.description);

    writeln!(file, "    def test_{}(self):", method_name)?;
    writeln!(file, "        \"\"\"{}\"\"\"", description)?;

    // Skip error cases with a TODO comment
    if case.expected.error_code.is_some() {
        writeln!(file, "        # TODO: Error case - expected error code: {}", 
                 case.expected.error_code.as_deref().unwrap_or("unknown"))?;
        writeln!(file, "        self.skipTest(\"Error case not yet implemented in generated tests\")")?;
        writeln!(file)?;
        return Ok(());
    }

    // Generate config
    writeln!(file, "        # Configuration")?;
    writeln!(file, "        config = zakatrs.ZakatConfig(")?;
    writeln!(file, "            gold_price=\"{}\",", escape_python_string(&case.config.gold_price_per_gram))?;
    writeln!(file, "            silver_price=\"{}\",", escape_python_string(&case.config.silver_price_per_gram))?;
    writeln!(file, "        )")?;
    writeln!(file)?;

    // Generate asset based on type
    match case.asset_type {
        AssetType::Business => generate_python_business_asset(file, case)?,
        AssetType::Gold => generate_python_gold_asset(file, case)?,
        AssetType::Silver => generate_python_silver_asset(file, case)?,
        _ => {
            writeln!(file, "        # TODO: Asset type {:?} not yet supported", case.asset_type)?;
            writeln!(file, "        self.skipTest(\"Asset type not yet supported\")")?;
            writeln!(file)?;
            return Ok(());
        }
    }

    // Generate assertions
    generate_python_assertions(file, case)?;

    writeln!(file)?;
    Ok(())
}

/// Generates Python code for a BusinessZakat asset.
fn generate_python_business_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let cash = get_field_str(&case.input.fields, "cash_on_hand", "0");
    let inventory = get_field_str(&case.input.fields, "inventory_value", "0");
    let receivables = get_field_str(&case.input.fields, "receivables", "0");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "        # Create business asset")?;
    writeln!(file, "        asset = zakatrs.BusinessZakat(")?;
    writeln!(file, "            cash_on_hand=\"{}\",", escape_python_string(&cash))?;
    writeln!(file, "            inventory_value=\"{}\",", escape_python_string(&inventory))?;
    writeln!(file, "            receivables=\"{}\",", escape_python_string(&receivables))?;
    writeln!(file, "            liabilities_due_now=\"{}\",", escape_python_string(liabilities))?;
    writeln!(file, "            hawl_satisfied={},", python_bool(hawl))?;
    writeln!(file, "        )")?;
    writeln!(file)?;
    writeln!(file, "        # Calculate")?;
    writeln!(file, "        result = asset.calculate(config)")?;

    Ok(())
}

/// Generates Python code for a Gold PreciousMetals asset.
fn generate_python_gold_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "24");
    let usage = get_field_str(&case.input.fields, "usage", "investment");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    // Check for non-Hanafi madhab (skip in generated tests like the original does)
    if case.config.madhab != "hanafi" {
        writeln!(file, "        # Non-Hanafi madhab not yet supported in Python API")?;
        writeln!(file, "        self.skipTest(\"Madhab '{}' not yet supported in Python API\")", 
                 escape_python_string(&case.config.madhab))?;
        return Ok(());
    }

    writeln!(file, "        # Create gold asset")?;
    writeln!(file, "        asset = zakatrs.PreciousMetals(")?;
    writeln!(file, "            weight_grams=\"{}\",", escape_python_string(&weight))?;
    writeln!(file, "            metal_type=\"Gold\",")?;
    writeln!(file, "            purity=\"{}\",", escape_python_string(&purity))?;
    writeln!(file, "            usage=normalize_usage(\"{}\"),", escape_python_string(&usage))?;
    writeln!(file, "            liabilities_due_now=\"{}\",", escape_python_string(liabilities))?;
    writeln!(file, "            hawl_satisfied={},", python_bool(hawl))?;
    writeln!(file, "        )")?;
    writeln!(file)?;
    writeln!(file, "        # Calculate")?;
    writeln!(file, "        result = asset.calculate(config)")?;

    Ok(())
}

/// Generates Python code for a Silver PreciousMetals asset.
fn generate_python_silver_asset(file: &mut File, case: &TestCase) -> io::Result<()> {
    let weight = get_field_str(&case.input.fields, "weight_grams", "0");
    let purity = get_field_str(&case.input.fields, "purity", "1000");
    let usage = get_field_str(&case.input.fields, "usage", "investment");
    let liabilities = &case.input.liabilities_due_now;
    let hawl = case.input.hawl_satisfied;

    writeln!(file, "        # Create silver asset")?;
    writeln!(file, "        asset = zakatrs.PreciousMetals(")?;
    writeln!(file, "            weight_grams=\"{}\",", escape_python_string(&weight))?;
    writeln!(file, "            metal_type=\"Silver\",")?;
    writeln!(file, "            purity=\"{}\",", escape_python_string(&purity))?;
    writeln!(file, "            usage=normalize_usage(\"{}\"),", escape_python_string(&usage))?;
    writeln!(file, "            liabilities_due_now=\"{}\",", escape_python_string(liabilities))?;
    writeln!(file, "            hawl_satisfied={},", python_bool(hawl))?;
    writeln!(file, "        )")?;
    writeln!(file)?;
    writeln!(file, "        # Calculate")?;
    writeln!(file, "        result = asset.calculate(config)")?;

    Ok(())
}

/// Generates Python assertion statements.
fn generate_python_assertions(file: &mut File, case: &TestCase) -> io::Result<()> {
    let case_id = escape_python_string(&case.id);
    let expected = &case.expected;
    let is_payable = python_bool(expected.is_payable);

    writeln!(file)?;
    writeln!(file, "        # Assertions")?;
    writeln!(file, "        self.assertEqual(")?;
    writeln!(file, "            result.is_payable,")?;
    writeln!(file, "            {},", is_payable)?;
    writeln!(file, "            \"[{}] is_payable mismatch\"", case_id)?;
    writeln!(file, "        )")?;
    
    writeln!(file, "        assert_decimal_equal(")?;
    writeln!(file, "            self,")?;
    writeln!(file, "            result.zakat_due,")?;
    writeln!(file, "            \"{}\",", escape_python_string(&expected.zakat_due))?;
    writeln!(file, "            \"[{}] zakat_due mismatch\"", case_id)?;
    writeln!(file, "        )")?;

    writeln!(file, "        assert_decimal_equal(")?;
    writeln!(file, "            self,")?;
    writeln!(file, "            result.net_assets,")?;
    writeln!(file, "            \"{}\",", escape_python_string(&expected.net_assets))?;
    writeln!(file, "            \"[{}] net_assets mismatch\"", case_id)?;
    writeln!(file, "        )")?;

    Ok(())
}

// ============================================================================
// Helper functions
// ============================================================================

/// Gets a field value as a string from the input fields map.
fn get_field_str(
    fields: &std::collections::HashMap<String, serde_json::Value>,
    key: &str,
    default: &str,
) -> String {
    fields
        .get(key)
        .and_then(|v| v.as_str())
        .unwrap_or(default)
        .to_string()
}

/// Converts a Rust bool to Python bool string.
fn python_bool(b: bool) -> &'static str {
    if b { "True" } else { "False" }
}

/// Sanitizes a string to be a valid Python identifier.
fn sanitize_python_identifier(s: &str) -> String {
    s.chars()
        .map(|c| if c.is_alphanumeric() || c == '_' { c } else { '_' })
        .collect()
}

/// Escapes a string for use in Python string literals.
fn escape_python_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}
